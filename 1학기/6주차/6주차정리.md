# 6주차 정리

# 사전(Dictionary)
+ 일상 생활에서 사용하는 사전처럼 이름과 그 이름에 대응되는 내용이 하나의 항목으로 연결되어 있는 자료구조
+ 하나의 항목은 이름(label)과 그 이름에 대응되는 내용(detail)이 한 쌍(pair)으로 연결되어 있다
+ 이름을 키(key) 내용을 값(value)라 한다
+ 따라서 사전에 있는 각각의 항목은 키-값의 쌍(key-value pair)이 된다

### 사전 생성
+ 사전은 여러 항목을 쉼포 ','기호로 구분하여 기재하고 양끝을 중괄호 '{}'로 씌워서 만든다
+ 각각의 항목은 키-값의 쌍으로써, 키와 값사이에 클론':'기호를 넣어서 키:값의 형태로 기재한다   
+ 이때 키는 변하지 않는(immutable) 값이어야 하고 사전 내에서 각각 유일한(unique) 값이어야 한다
```python
    d1 = {"name":"홍길동","birth":"1월1일"}
    d2 = {2016:"원숭이",2017:"닭",2018:"개",2019:"돼지",2020:"쥐"}
    d3 = {("홍길동","000000"):[1,2,3],("김철수","111111"):[4,5,6]}
    d4 = {}
    d5 = dict()
    print(d1)#{'name': '홍길동', 'birth': '1월1일'}
    print(d2)#{2016: '원숭이', 2017: '닭', 2018: '개', 2019: '돼지', 2020: '쥐'}
    print(d3)#{('홍길동', '000000'): [1, 2, 3], ('김철수', '111111'): [4, 5, 6]}
    print(d4)#빈 사전
    print(d5)#빈 사전
```
### 사전 내의 1개의 값 접근
+ 사전에 있는 항목의 값을 특정하려면 사전의 이름 뒤에 그 항목의 키를 기재하고 양 쪽 끝을 대괄호기호로 씌워 접근할수 있다
+ 사전의 항목들에는 순서가 없으며 인덱스가 존재하지 않는다
```python
    d1 = {"name":"홍길동","birth":"1월1일"}
    print(d1["name"]) # 홍길동
```
+ 명령어 get을 이용하여 항목의 키에 대응하는 값을 가져올수 있다
+ get을 사용하는 경우, 키가 존재하지 않으면 None이라는 값을 되돌려준다
+ None은 "아무 것도 없음","아무 것도 아님"을 의미하는 특수한 자료형
```python
    d2 = {2016:"원숭이",2017:"닭",2018:"개",2019:"돼지",2020:"쥐"}
    print(d2.get(2016))#원숭이
```
### 사전의 특정 값 수정
+ 사전의 이름[항목의 키] = 수정할 값 또는 연산
```python
    d1 = {"name":"홍길동","birth":"1월1일"}
    d1["name"] = "이름변경"
    print(d1.get("name"))# 이름변경
    d3 = {("홍길동","000000"):[1,2,3],("김철수","111111"):[4,5,6]}
    print(d3)#{('홍길동', '000000'): [1, 2, 3], ('김철수', '111111'): [4, 5, 6]}
    d3[("홍길동","000000")][-1] = 200
    print(d3)#{('홍길동', '000000'): [1, 2, 200], ('김철수', '111111'): [4, 5, 6]}
```
### 사전에 새로운 항목 1개 추가
+ 사전의 이름[새로운 키] = 추가할 값 또는 연산
```python
    addD = {"num1":1}

    print(addD)#{'num1': 1}
    addD["num2"] = 2
    print(addD)#{'num1': 1, 'num2': 2}
```
### 사전에서 항목 삭제
+ del 사전의 이름[삭제하려는 항목의 키]
```python
    print(addD)#{'num1': 1, 'num2': 2}
    del addD["num2"]
    print(addD)#{'num1': 1}
```

### 사전에서 키 모음 가져오기
+ 사전의 이름.keys()
+ 대상 사전 내의 모든 항목들의 키들을 모아서 가져온다
+ 자료 구조 dict_keys는 리스트로 변환할 수 있다
```python
    d2 = {2016:"원숭이",2017:"닭",2018:"개",2019:"돼지",2020:"쥐"}
    k1 = d2.keys()
    print(k1)#dict_keys([2016, 2017, 2018, 2019, 2020])
```
### 사전에서 값 모음 가져오기
+ 사전의이름.values()
+ 대상 사전 내의 모든 항목들의 값들을 모아서 가져온다
+ 자료 구조 dict_values는 리스트로 변환할 수 있다
```python
    d2 = {2016:"원숭이",2017:"닭",2018:"개",2019:"돼지",2020:"쥐"}
    v1 = d2.values()
    print(v1)#dict_values(['원숭이', '닭', '개', '돼지', '쥐'])
```

### 사전에서 키-값의 쌍 모음 가져오기
+ 사전의이름.items()
+ 대상 사전 내의 각 항목, 즉 키와 값의 쌍 1개를 하나의 튜플 형태로 만든 뒤, 이 튜플들을 모아서 가져온다
+ 자료 구조 dict_items는 리스트로 변환할 수 있다
+ 사전은 결국 내부적으로 항목이 2개인 튜플들이 모여 있는 리스트와 마찬가지이다
```python
    d2 = {2016:"원숭이",2017:"닭",2018:"개",2019:"돼지",2020:"쥐"}
    i1 = d2.items()
    print(i1)#dict_items([(2016, '원숭이'), (2017, '닭'), (2018, '개'), (2019, '돼지'), (2020, '쥐')])
```

### 사전에 특정 키가 존재하는지 확인
+ 찾으려는키 in 사전의 이름 또는 사전의 리름.keys()
    + 값이 있다면 True를 반환
+ 찾으려는 키 not in 사전의 이름 또는 사전의 이름.keys( )
    + 값이 없다면 False를 반환
```python
    d2 = {2016:"원숭이",2017:"닭",2018:"개",2019:"돼지",2020:"쥐"}
    print(2016 in d2)#True
    print(2015 in d2)#False
    print(2015 not in d2)#True
    print(2016 not in d2)#False
```

### 사전에 특정 값이 존재 하는지 확인
+ 찾으려는 키 in 사전의 이름.values()
    + 사전에 값이 있다면 True를 반환
+ 찾으려는 키 not in 사전의 이름.values()
    + 사전에 값이 없다면 True를 반환
```python
    d2 = {2016:"원숭이",2017:"닭",2018:"개",2019:"돼지",2020:"쥐"}
    print("쥐" in d2.values())#True
    print("범" in d2.values())#False
    print("쥐" not in d2.values())#False
    print("범" not in d2.values())#True
```

### 사전에 특정 키-값의 쌍이 존재하는지 확인
+ 찾으려는 키 in 사전의 이름.items()
    + 값이 있다면 True반환
+ 찾으려는 키 not in 사전의 이름.items()
    + 값이 있다면 False반환
```python
    d2 = {2016:"원숭이",2017:"닭",2018:"개",2019:"돼지",2020:"쥐"}
    print((2020,"쥐") in d2.items())#True
    print((2020,"범") in d2.items())#False
    print((2020,"쥐") not in d2.items())#False
    print((2020,"범") not in d2.items())#True
```

### 사전의 길이 구하기
+ len(사전의 이름)
```python
    d2 = {2016:"원숭이",2017:"닭",2018:"개",2019:"돼지",2020:"쥐"}
    print(len(d2))#5
```

### 사전의 자료형 확인
+ type(자료형을 확인할 1개의 자료)
```python
    d2 = {2016:"원숭이",2017:"닭",2018:"개",2019:"돼지",2020:"쥐"}
    print(type(d2))#<class 'dict'>
    print(type(d2[2016]))#<class 'str'>
    d3 = {("홍길동","000000"):[1,2,3],("김철수","111111"):[4,5,6]}
    print(type(d3))#<class 'dict'>
    print(type(d3[("홍길동","000000")]))#<class 'list'>
```

### 명령어를 사용한 사전 생성
+ 사전의 이름 = dict(키1=값1,키2=값2,...)
+ 명령어 dirct를 이용하여 새로운 사전을 만듬
+ 이렇게 만들 경우, 키는 변수명 형태로 기재해야한다
```python
    d1 = dict(name = "이름1",birth = "생일",job = "직업")
    print(d1)#{'name': '이름1', 'birth': '생일', 'job': '직업'}
    d2 = dict(Y2016 = "원숭이",Y2017 = "닭")
    print(d2)#{'Y2016': '원숭이', 'Y2017': '닭'}
    
    #변수명 형태가 아니기 때문에 Error
    d3 = dict(2016 = "원숭이",2017 = "닭")#SyntaxError
    print(d3)
```

### 항목이 튜플인 리스트를 사전 자료형으로 변환
+ 사전의 이름 = dict(변환하려는 리스트)
```python
    name = "이름"
    birth = "생일"
    job = "직업"
    t1 = "name",name
    t2 = "birth",birth
    t3 = "job",job
    
    data = [t1,t2,t3]
    print(data)#[('name', '이름'), ('birth', '생일'), ('job', '직업')]
    
    d1_list = dict(data)
    print(d1_list)#{'name': '이름', 'birth': '생일', 'job': '직업'}
```

### 사전에 다른 사전 결합
+ 사전의 이름.update(결합할 1개의 사전)
+ 대상 사전에 다른 사전을 결합하여 확장
+ 동일한 키가 존재하는 경우, 원래 사전에 있는 값은 결합할 사전의 값으로 대체
```python
    print(d1_list)#{'name': '이름', 'birth': '생일', 'job': '직업'}
    d1_other = {"birth":"생일2","company":"직장","position":"계급"}
    d1_list.update(d1_other)
    print(d1_list)#{'name': '이름', 'birth': '생일2', 'job': '직업', 'company': '직장', 'position': '계급'}
```
### 사전을 만들때 주의할 점
+ 키는 변하지 않는 값이어야 하기 때문에 , 리스트 또는 사전을 사전의 키로 사용할 수 없다
```python
    d = {[1,2,3]:"one,two,three"}
    print(d)#TypeError: unhashable type: 'list'
```
+ 키는 사전 내에서 유일한 값이어야 한다. 그렇지 않으면 정상적으로 동작한다는 것을 보장할수 없다
```python
    d = {"name":"이름1","name":"이름2","bitrh":"생일"}
    print(d)#{'name': '이름2', 'bitrh': '생일'}
```